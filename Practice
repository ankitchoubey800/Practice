.Net Core:
Code for app.Use, app.Map & app.Run:


Go To Top
 
 
InProcess v/s OutOfProcess Hosting
 

InProcess Hosting:

Kestrel Server with and without Proxy Server (OutOfProcess Hosting)

Kestrel can also be used in combination with a reverse proxy server, such as IIS, Nginx, or Apache.

Go To Top
 
Create a simple middleware.
Lets move the code from the Use to a separate class:

For us to be able to use this middleware in our application we will have to make an extension method:

Now we can use this UseSampleMiddleware extension method inside of our code:

That looks much cleaner. We extracted specific code to separate method/class, which is always a nice thing to do.
 
Go To Top
 
Main() Method Explanation:

CreateWebHostBuilder returns an object of IWebHostBuilder which is then built using .Build(), which in turn builds the WebHost. Run() runs the web application and it starts listening for the incoming HTTP requests.
CreateDefaultBuilder() sets up the webHost that hosts our application with pre-configured defaults.
Go To Top
 
Web API:
What are the main return types supported in Web API?
A Web API controller action can return following values:
Void – It will return empty content
HttpResponseMessage – It will convert the response to an HTTP message.
IHttpActionResult – internally calls ExecuteAsync to create an HttpResponseMessage
Other types – You can write the serialized return value into the response body
Go To Top
 
What are HTTP Status Codes?

S. No.	   HTTP Status Code	    Description
1.		1XX		  Informational
2.		2XX		  Success
3.		3XX		  Redirection
4.		4XX		  Client-Side Error
5.		5XX		  Server-Side ErrorTable: HTTP Status Code with Description
Some of the commonly seen HTTP Status Codes are: 200 (Request is Ok), 201 (Created), 202 (Accepted), 204 (No Content), 301 (Moved Permanently), 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 500 (Internal Server Error), 502 (Bad Gateway), 503 (Service Unavailable) etc.
Go To Top
 
Versioning of WebAPI:
 
URI - Convention based routing:
WebApiConfig.cs file:


URI - Attribute based routing:

We also have other ways of versioning like: Query String Parameter, eg. (/api/students?v=1, /api/students?v=2),  Accept Header Parameter , eg.     &
CustomHeaderParameter. Eg, 
Go To Top
 
How a controller is selected when a request is issued to the following URI? ‘/api/students/1’
In Web API, there is a class called DefaultHttpControllerSelector. This class has a method called SelectController() that selects the controller based on the information it has in the URI.
Go To Top
 
How to construct HtmlResponseMessage?
public HttpResponseMessage GetEmployeeById(long id) {  
    try {  
Employee emp = csharp.Employees.Where(a => a.ID==id).FirstOrDefault();  
 if (emp != null) {  
return Request.CreateErrorResponse <Employee> (HttpStatusCode.OK, emp);  
        } else {  
 return Request.CreateErrorResponse(HttpStatusCode.NotFound, "Emplyee not found");  
        }  
    } catch (Exception ex) {  
        	return Request.CreateErrorResponse(HttpStatusCode.InternalServerError, ex.Message);  
    }  
}  
 
Code for returning 404 error from HttpError
string message = string.Format(“TestCustomer id = {0} not found”, customerid);
return Request.CreateErrorResponse(HttpStatusCode.NotFound, message);

Go To Top

How Can assign alias name for ASP.NET Web API Action?

Go To Top
 
What are different ways to handle exception in WebAPI?
Using HttpResponseException: It returns HTTP status code.

Using HttpError: CreateErrorResponse method of Request object helps us to return meaningful error code and message to the client. CreateErrorResponse creates an instance of HttpError object and returns it as HttpResponseMessage object.

Using Exception Filters: This is an attribute so we can decorate both action method and controller with this.



To apply the exception filter to all Web API controllers, the filter needs to register to GlobalConfiguration.Configuration.Filters collection.

Go To Top
 
ReactJS
React Component Lifecycle:
The component lifecycle has three distinct lifecycle phases:
Mounting: React has four built-in methods that gets called, in this order, when mounting a component:
constructor()
getDerivedStateFromProps()-This is the natural place to set the state object based on the initial props.
render()
componentDidMount()- This is where you run statements that require that the component is already placed in the DOM.
Updating:  The next phase in the life cycle is when a component is updated.
A component is updated whenever there is a change in the component's state or props.
React has five built-in methods that gets called, in this order, when a component is updated:
getDerivedStateFromProps()
shouldComponentUpdate()-In this method you can return a Boolean value that specifies whether React should continue with the rendering or not.
render()
getSnapshotBeforeUpdate()-In this method you have access to the props and state before the update, meaning that even after the update, you can check what the values were before the update.
componentDidUpdate()
Unmounting:
 In this last phase, the component is not needed and gets unmounted from the browser DOM. This phase includes componentWillUnmount() lifecycle method.

Reference: https://www.w3schools.com/react/react_lifecycle.asp
React 16.3+ Phases (or an interactive version)



Go To Top
Creating React Elements using CreateElement:
const element = React.createElement(
  'div',
  {id: 'login-btn'},
  'Login'
)
<div id='login-btn'>Login</div>
Then JSX gets transpiled to a React.createElement() function tree.
Go To Top
Function Component & Class Component syntax
function Greeting({ message }) {
  return <h1>{`Hello, ${message}`}</h1>

}
 
class Greeting extends React.Component {
  render() {
    return <h1>{`Hello, ${this.props.message}`}</h1>
  }
}
Go To Top
Why should we not update the state directly?
If you try to update the state directly then it won't re-render the component.
//Wrong
this.state.message = 'Hello world'
Instead use setState() method. It schedules an update to a component's state object. When state changes, the component responds by re-rendering.
//Correct
this.setState({ message: 'Hello World' })
Go To Top
How to bind methods or event handlers in JSX callbacks?
There are 3 possible ways to achieve this:
Binding in Constructor: In JavaScript classes, the methods are not bound by default. The same thing applies for React event handlers defined as class methods. Normally we bind them in constructor.
class Component extends React.Componenet {
  constructor(props) {
    super(props)
    this.handleClick = this.handleClick.bind(this)
  }
  handleClick() { // ...  } }
<button onClick={this.handleClick} />  ->you can access it like this.props since this will then refer to the React Component's context and not the function itself.
Public class fields syntax: If you don't like to use bind approach then public class fields syntax can be used to correctly bind callbacks.
handleClick = () => {
  console.log('this is:', this)
}
<button onClick={this.handleClick}>
  {'Click me'}
</button>
Arrow functions in callbacks: You can use arrow functions directly in the callbacks.
<button onClick={(event) => this.handleClick(event)}>
  {'Click me'}
</button>
Go To Top
What are "key" props and why we use them in arrays?
A key is a special string attribute you should include when creating arrays of elements. Keys help React identify which items have changed, are added, or are removed.
Most often we use IDs from our data as keys:
const todoItems = todos.map( (todo) =>
  				<li key={todo.id}>{todo.text}</li> )
Go To Top
How to create refs?
There are two approaches
React.createRef(): Refs are created using React.createRef() method and attached to React elements via the ref attribute.
class MyComponent extends React.Component {
  constructor(props) {
    super(props)
    this.myRef = React.createRef()
  }
  render() {
    return <div ref={this.myRef} />
  }
}
Callback approach: You can also use ref callbacks approach regardless of React version. For example, the search bar component's input element accessed as follows,
class SearchBar extends Component {
   constructor(props) {
      super(props);
      this.txtSearch = null;
      this.state = { term: '' };
      this.setInputSearchRef = e => { this.txtSearch = e; }
   }
   onInputChange(event) { this.setState({ term: this.txtSearch.value });  }
   render() {
      return (
         <input value={this.state.term}
            onChange={this.onInputChange.bind(this)}
            ref={this.setInputSearchRef} /> );  
} }
Go To Top
What are controlled and uncontrolled components?
// Controlled: <input type="text" value={value} onChange={handleChange} /> // 
Uncontrolled: <input type="text" defaultValue="foo" ref={inputRef} /> // Use `inputRef.current.value` to read the current value of <input>
Go To Top
 
Children prop:
Allows you to pass components as data to other components.
const MyDiv = React.createClass({
  render: function() {
    return <div>{this.props.children}</div>
  }
})

ReactDOM.render(
  <MyDiv>
    <span>{'Hello'}</span>
    <span>{'World'}</span>
  </MyDiv>
)
Go To Top
What is the recommended ordering of methods in component class?
Recommended ordering of methods from mounting to render stage:
static methods
constructor()
getChildContext()
componentWillMount()
componentDidMount()
componentWillReceiveProps()
shouldComponentUpdate()
componentWillUpdate()
componentDidUpdate()
componentWillUnmount()
click handlers or event handlers like onClickSubmit() or onChangeDescription()
getter methods for render like getSelectReason() or getFooterContent()
optional render methods like renderNavigation() or renderProfilePicture()
render()
Go To Top

How to get query parameters in React Router v4?
const queryString = require('query-string');
const parsed = queryString.parse(props.location.search);
Go To Top
How to implement default or NotFound page?
A <Route> element with no path within <switch> will redirect to the ‘NotFound’ page.
<Switch>
  <Route exact path="/" component={Home}/>
  <Route path="/user" component={User}/>
  <Route component={NotFound} />
</Switch>
Go To Top
What is the main purpose of constructor?
The constructor is mainly used for two purposes,
To initialize local state by assigning object to this.state
For binding event handler methods
constructor(props) {
  super(props);
  // Don't call this.setState() here!
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}
Go To Top
 
React Routing
React Router is a powerful routing library built on top of React that helps you add new screens and flows to your application incredibly quickly, all while keeping the URL in sync with what's being displayed on the page.
import { Route, Link, BrowserRouter as Router } from 'react-router-dom'
 
<Router>
      <div>
        <Route exact path="/" component={App} />
        <Route path="/R&D" component={ResearchDev} />
        <Route path="/signup" component={SignUp} />
      </div>
    </Router>
 
<li className="nav-item">
              {/* <a className="nav-link">R & D</a> */}
              <Link to="/R&D" className="nav-link">R & D</Link>
            </li>
 

We can apply routing in our react app just by adding the above line of codes.
Go To Top
 
Redux


Go To Top
 
C#
 
Generic and non-Generic Collections
Collections are a set of classes that provides array functionality in a superior manner. Collections: Array Size is not fixed & Elements can be added / removed at runtime.
Every collection class implements the IEnumerable interface so values from the collection can be accessed using a foreach loop.
There are the following 2 types of collections:
Non-Generic: Each element can represent a value of a different type.
Generic: Generic Collections work on the specific type that is specified in the program whereas non-generic collections work on the object type.
Non-generic—-——->Generic
 ArrayList ----------------> List
 HashTable -------------> Dictionary
 SortedList --------------> SortedList
 Stack --------------------> Stack
 Queue -------------------> Queue
Go To Top
 
Why list over Arraylist? 
Performance
Type-safe
Can use LINQ
Yes, pretty much. List<T> is a generic class. It supports storing values of a specific type without casting to or from object (which would have incurred boxing/unboxing overhead when T is a value type in the ArrayList case). ArrayList simply stores object references. As a generic collection, List<T> implements the generic IEnumerable<T> interface and can be used easily in LINQ (without requiring any Cast or OfType call).
Go To Top
 
Can interfaces & abstract classes have properties? Can they have constructors? Can an interface and abstract class inherit?
Yes, abstract & interfaces can have properties.
Abstract class can HAVE constructor even though it cannot be initiated, this constructor can be used to initiate common properties, e.g., GUID for each derived class. interfaces CANNOT HAVE constructors.
Abstract class constructor is automatically called by derived class constructor (Parent class constructor is called first followed by child class constructor)
Yes, An Abstract class can inherit from a concrete class(non-Abstract class) and can also inherit from the following-Abstract Class, Concrete class, Interface
An interface can inherit from another interface. Interface members are automatically public, and they can't include any access modifiers.
Also, we cannot create objects of neither interfaces nor abstract classes.
We cannot inherit from two abstract classes .i.e. Multiple inheritance is not allowed.
Go To Top

Why do we use abstract class & Interface class? Which is better?
Interface use: 
Suppose you have a project with a lot of classes and you want each class to compulsorily have some methods.
Dependency Injection.
Abstract class: If the method is abstract, you must override. If the method is virtual, you can override but not necessarily.
With an Abstract Class, we can provide some kind of default functionality for all derived classes to extend from. This is useful to avoid code duplication in many cases.
Go To Top
 
What are anonymous methods?

If there is only one line of code which has to do the task, then anonymous methods improve the performance instead of creating a normal function.
Go To Top
 
Dispose & Finalize:

The GC checks the object's header. If it has 'Finalize' property in it, then it moves the object to the finalize queue. Checking of finalize by GC happens very less frequently and we don't have any control over it. So, it stays in the memory for a long time after the object's work is done.
-We can implement 'Finalize' method by using Destructor.
public class MyClass : IDisposable
{
private bool disposed = false;
//Implement IDisposable.
public void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}
protected virtual void Dispose(bool disposing)
{
if (!disposed)
{
if (disposing)
{
// TO DO: clean up managed objects
}
// TO DO: clean up unmanaged objects
disposed = true;
}
}
//At runtime C# destructor is automatically Converted to Finalize method
~MyClass()
{
Dispose(false);
}
}
We also have a GC.Collect() method->deactivate all the inactive object's memory-called by users explicitly to call. GC.-It is a very expensive operation.-it will also call the finalize() method for the classes which have used destructor to release all the memory including finalize block.
Go To Top
 
Singleton Design Pattern.
Singleton Pattern belongs to Creational type pattern. Singleton design patterns are used when we need to ensure that only one object of a particular class is Instantiated. 
Program.cs
 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/// <summary>
/// First version of Singleton demo
/// </summary>
namespace SingletonDemo
{
    class Program
	{
        static void Main(string[] args)
    	{
            /*
         	* Assuming Singleton is created from employee class
         	* we refer to the GetInstance property from the Singleton class
         	*/
            Singleton fromEmployee = Singleton.GetInstance;
        	fromEmployee.PrintDetails("From Employee");
            /*
         	* Assuming Singleton is created from student class
         	* we refer to the GetInstance property from the Singleton class
         	*/
            Singleton fromStudent = Singleton.GetInstance;
        	fromStudent.PrintDetails("From Student");
 
            Console.ReadLine();
    	}
	}
}
 
Singleton.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/// <summary>
/// First Singleton version
/// </summary>
namespace SingletonDemo
{
    /*
 	*  Sealed ensures the class being inherited and
 	*  object instantiation is restricted in the derived class
 	*/
    public sealed class Singleton
	{
        private static int counter = 0;
 
        /*
     	* Private property initilized with null
     	* ensures that only one instance of the object is created
     	* based on the null condition
     	*/
        private static Singleton instance = null;
       
        /*
     	* public property is used to return only one instance of the class
     	* leveraging on the private property
     	*/
        public static Singleton GetInstance
    	{
            get
        	{
                if (instance == null)
                	instance = new Singleton();
                return instance;
     	   }
    	}
        /*
     	* Private constructor ensures that object is not
     	* instantiated other than with in the class itself
     	*/
        private Singleton()
    	{
        	counter++;
            Console.WriteLine("Counter Value " + counter.ToString());
    	}
        /*
     	* Public method which can be invoked through the singleton instance
     	*/
        public void PrintDetails(string message)
    	{
            Console.WriteLine(message);
    	}
	}
}
Go To Top
 
Factory Design Pattern.
Factory Method is a Design Pattern which defines an interface for creating an object but lets the classes that implement the interface decide which class to instantiate. Factory Pattern lets a class postpone instantiation to sub-classes.
 
The factory pattern is used to replace class constructors, abstracting the process of object generation so that the type of the object instantiated can be determined at run-time.
 
In this article, I have tried to cover the Concept of Factory Method design pattern and the way of implementing the Factory Method design pattern.
Where to Use It?
It is tedious when the client needs to specify the class name while creating the objects. So, to resolve this problem, we can use Factory Method design pattern. It provides the client with a simple way to create the object.
 
The classes and objects participating in the above UML class diagram are as follows:
Product
 
This defines the interface of objects the factory method creates
ConcreteProduct
 
This is a class which implements the Product interface.
Creator
 
This is an abstract class and declares the factory method, which returns an object of type Product.
 
This may also define a default implementation of the factory method that returns a default ConcreteProduct object.
This may call the factory method to create a Product object.
ConcreteCreator
 
This is a class which implements the Creator class and overrides the factory method to return an instance of a ConcreteProduct.
Now let’s understand this with a real world example
 
Assume you have three different cards which are considered here as classes MoneyBack, Titanium and Platinum, all of them implement abstract class CreditCard. You need to instantiate one of these classes, but you don't know which of them, it depends on the user. This is perfect scenario for the Factory Method design pattern.
Who is what?
The classes and objects participating in the above class diagram can be identified as follows:
Product - CreditCard
ConcreteProduct- MoneyBackCreditCard, TitaniumCreditCard, PlatinumCreditCard
Creator- CardFactory
ConcreteCreator- MoneyBackCardFactory, TitaniumCardFactory, PlatinumCardFactory
Here are the code blocks for each participant
Product
namespace FactoryMethodDesignPatternInCSharp  
{  
    /// <summary>  
    /// The 'Product' Abstract Class  
    /// </summary>  
    abstract class CreditCard  
    {  
        public abstract string CardType { get; }  
        public abstract int CreditLimit { get; set; }  
        public abstract int AnnualCharge { get; set; }  
    }     
}  
ConcreteProduct
 
MoneyBackCreditCard:
using System;  
  
namespace FactoryMethodDesignPatternInCSharp  
{  
    /// <summary>  
    /// A 'ConcreteProduct' class  
    /// </summary>  
    class MoneyBackCreditCard : CreditCard  
    {  
        private readonly string _cardType;  
        private int _creditLimit;  
        private int _annualCharge;  
  
        public MoneyBackCreditCard(int creditLimit, int annualCharge)  
        {  
            _cardType = "MoneyBack";  
            _creditLimit = creditLimit;  
            _annualCharge = annualCharge;  
        }  
  
        public override string CardType  
        {  
            get { return _cardType; }  
        }  
  
        public override int CreditLimit  
        {  
            get { return _creditLimit; }  
            set { _creditLimit = value; }  
        }  
  
        public override int AnnualCharge  
        {  
            get { return _annualCharge; }  
            set { _annualCharge = value; }  
        }  
    }  
}  
TitaniumCreditCard:
using System;  
  
namespace FactoryMethodDesignPatternInCSharp  
{  
    /// <summary>  
    /// A 'ConcreteProduct' class  
    /// </summary>  
    class TitaniumCreditCard : CreditCard  
    {  
        private readonly string _cardType;  
        private int _creditLimit;  
        private int _annualCharge;  
  
        public TitaniumCreditCard(int creditLimit, int annualCharge)  
        {  
            _cardType = "Titanium";  
            _creditLimit = creditLimit;  
            _annualCharge = annualCharge;  
        }  
  
        public override string CardType  
        {  
            get { return _cardType; }  
        }  
  
        public override int CreditLimit  
        {  
            get { return _creditLimit; }  
            set { _creditLimit = value; }  
        }  
  
        public override int AnnualCharge  
        {  
            get { return _annualCharge; }  
            set { _annualCharge = value; }  
        }      
    }  
}  
PlatinumCreditCard:
using System;  
  
namespace FactoryMethodDesignPatternInCSharp  
{  
    /// <summary>  
    /// A 'ConcreteProduct' class  
    /// </summary>  
    class PlatinumCreditCard : CreditCard  
    {  
        private readonly string _cardType;  
        private int _creditLimit;  
        private int _annualCharge;  
  
        public PlatinumCreditCard(int creditLimit, int annualCharge)  
        {  
            _cardType = "Platinum";  
            _creditLimit = creditLimit;  
            _annualCharge = annualCharge;  
        }  
  
        public override string CardType  
        {  
            get { return _cardType; }  
        }  
  
        public override int CreditLimit  
        {  
            get { return _creditLimit; }  
            set { _creditLimit = value; }  
        }  
  
        public override int AnnualCharge  
        {  
            get { return _annualCharge; }  
            set { _annualCharge = value; }  
        }  
    }  
}  
Creator
namespace FactoryMethodDesignPatternInCSharp  
{  
    /// <summary>  
    /// The 'Creator' Abstract Class  
    /// </summary>  
    abstract class CardFactory  
    {  
        public abstract CreditCard GetCreditCard();  
    }  
}  
ConcreteCreator
 
MoneyBackFactory: 
namespace FactoryMethodDesignPatternInCSharp  
{  
    /// <summary>  
    /// A 'ConcreteCreator' class  
    /// </summary>  
    class MoneyBackFactory : CardFactory  
    {  
        private int _creditLimit;  
        private int _annualCharge;  
  
        public MoneyBackFactory(int creditLimit, int annualCharge)  
        {  
            _creditLimit = creditLimit;  
            _annualCharge = annualCharge;  
        }  
  
        public override CreditCard GetCreditCard()  
        {  
            return new MoneyBackCreditCard(_creditLimit, _annualCharge);  
        }  
    }  
}  
TitaniumFactory:
namespace FactoryMethodDesignPatternInCSharp      
{      
    class TitaniumFactory: CardFactory      
    {      
        private int _creditLimit;      
        private int _annualCharge;      
      
        public TitaniumFactory(int creditLimit, int annualCharge)      
        {      
            _creditLimit = creditLimit;      
            _annualCharge = annualCharge;      
        }      
      
        public override CreditCard GetCreditCard()      
        {      
            return new TitaniumCreditCard(_creditLimit, _annualCharge);      
        }      
    }      
}    
PlatinumFactory:
namespace FactoryMethodDesignPatternInCSharp      
{      
    class PlatinumFactory: CardFactory      
    {      
        private int _creditLimit;      
        private int _annualCharge;      
      
        public PlatinumFactory(int creditLimit, int annualCharge)      
        {      
            _creditLimit = creditLimit;      
            _annualCharge = annualCharge;      
        }      
      
        public override CreditCard GetCreditCard()      
        {      
            return new PlatinumCreditCard(_creditLimit, _annualCharge);      
        }      
    }      
}   
Factory Pattern Client Demo
using System;  
  
namespace FactoryMethodDesignPatternInCSharp  
{  
    /// <summary>  
    /// Factory Pattern Demo  
    /// </summary>    
    public class ClientApplication  
    {  
        static void Main()  
        {  
            CardFactory factory = null;  
            Console.Write("Enter the card type you would like to visit: ");  
            string car = Console.ReadLine();  
  
            switch (car.ToLower())  
            {  
                case "moneyback":  
                    factory = new MoneyBackFactory(50000, 0);  
                    break;  
                case "titanium":  
                    factory = new TitaniumFactory(100000, 500);  
                    break;  
                case "platinum":  
                    factory = new PlatinumFactory(500000, 1000);  
                    break;  
                default:  
                    break;  
            }  
  
            CreditCard creditCard = factory.GetCreditCard();  
            Console.WriteLine("\nYour card details are below : \n");  
            Console.WriteLine("Card Type: {0}\nCredit Limit: {1}\nAnnual Charge: {2}",  
                creditCard.CardType, creditCard.CreditLimit, creditCard.AnnualCharge);  
            Console.ReadKey();  
        }  
    }  
}   
Output
 
Here, we are accepting input from the clients/users as to which class they want to instantiate.
 

 
Enter the respective card type: (MoneyBack/Titanium/Platinum)
 

  

Go To Top
 
Explain Dependency Injection.
Constructor Injection:
public interface IService {
 void Serve();
}
public class Service1 : IService {
 public void Serve() { Console.WriteLine("Service1 Called"); }
}
public class Service2 : IService {
 public void Serve() { Console.WriteLine("Service2 Called"); }
}
public class Client {
 private IService _service;
 public Client(IService service) {
 this._service = service;
 }
 public ServeMethod() { this._service.Serve(); }
}

class Program
{
 static void Main(string[] args)
 {
 //creating object
 Service1 s1 = new Service1(); 
 //passing dependency
 Client c1 = new Client(s1);
 //TO DO:

 Service2 s2 = new Service2(); 
 //passing dependency
 c1 = new Client(s2);
 //TO DO:
 }
}
Property Injection:
public interface IService {
 void Serve();
}
public class Service1 : IService {
 public void Serve() { Console.WriteLine("Service1 Called"); }
}
public class Service2 : IService {
 public void Serve() { Console.WriteLine("Service2 Called"); }
}
public class Client {
 private IService _service;
 public IService Service {
 set { this._service = value; }
 }
 public ServeMethod() { this._service.Serve(); }
}

class Program
{
 static void Main(string[] args)
 {
 //creating object
 Service1 s1 = new Service1(); 
 
 Client client = new Client();
 client.Service = s1; //passing dependency
 //TO DO:

 Service2 s2 = new Service2(); 
 client.Service = s2; //passing dependency
 //TO DO:
 }
}


Method Injection:
public interface IService {
 void Serve();
}
public class Service1 : IService {
 public void Serve() { Console.WriteLine("Service1 Called"); }
}
public class Service2 : IService {
 public void Serve() { Console.WriteLine("Service2 Called"); }
}
public class Client {
 private IService _service;
 public void Start(IService service) {
 service.Serve();
 }
}

class Program
{
 static void Main(string[] args)
 {
 //creating object
 Service1 s1 = new Service1(); 
 
 Client client = new Client(); 
 client.Start(s1); //passing dependency
 //TO DO:
 
 Service2 s2 = new Service2(); 
 client.Start(s2); //passing dependency
 }
}
Go To Top
Design Patterns:
They are Creational, Structural and Behavioural.
Creational design patterns : These patterns deal with object creation and initialization. Examples of Creational design patterns category : Singleton , Factory and Abstract Factory etc.
Structural design patterns : This pattern deals with class and object composition. In simple words, This pattern focuses on decoupling interface, implementation of classes and its objects. Examples of Structural design patterns category : Adapter,  Facade and Bridge etc.
Behavioural design patterns : These patterns deal with communication between Classes and objects. Examples of Behavioural design patterns : Chain of Responsibility, Command and Interpreter etc.
Go To Top
 
Delegates.
Delegate is similar to a function pointer in C & C++ but the delegates are user defined types in C#. Make a note that delegates are not a member of class, but similar to a class. These are the backbone for events.
When to use delegates?
I believe that a lot of people can answer the "what is a delegate?" question in interviews but are not able to explain when to use it. No worries! Let me tell you a few important points about delegates.
These are used to represent or refer to one or more functions.
These can only be used to define call-back methods.
In order to consume a delegate, we need to create an object to delegate.
How many types of delegates are present?
There are two types of delegates available.
Single Cast Delegate
Multi Cast Delegate
Single Cast Delegate
A delegate that represents only a single function is known as Single Cast Delegate.
Multi Cast Delegate
A delegate that represents more than one function is known as Multi Cast Delegate.
Single Cast Delegate
Let’s see a sample program on Single Delegate to refer a function in the same class.
Code 
using System;  
using System.Collections.Generic;  
using System.Linq;  
using System.Text;  
using System.Threading.Tasks;  
namespace DelegatesDemo {  
    class Program {  
        static void Display(string S) {  
            Console.WriteLine("My Name is :" + S);  
        }  
        delegate void X(string a);  
        static void Main(string[] args) {  
            X objD = new X(Display);  
            objD("Rathrola Prem Kumar");  
            Console.Read();  
        }  
    }  
}   
Sample Program for Multi cast delegate 
using System;  
using System.Collections.Generic;  
using System.Linq;  
using System.Text;  
using System.Threading.Tasks;  
namespace DelegatesDemo {  
    class Program {  
        public void Add(int x, int y) {  
            Console.WriteLine("Sum is:" + (x + y));  
        }  
        public void Subtract(int x, int y) {  
            Console.WriteLine("Difference is:" + (x - y));  
        }  
        public void Multiply(int x, int y) {  
            Console.WriteLine("Product is:" + (x * y));  
        }  
        public void Divide(int x, int y) {  
            Console.WriteLine("Quotient is:" + (x / y));  
        }  
    }  
    public delegate void MultiCastDelegate(int a, int b);  
    class ClsDelegate {  
        static void Main() {  
            Program obj1 = new Program();  
            MultiCastDelegate objD = new MultiCastDelegate(obj1.Multiply);  
            objD += obj1.Add;  
            objD += obj1.Substract;  
            objD += obj1.Divide;  
            objD(40, 10);  
            objD -= obj1.Add;  
            objD -= obj1.Divide;  
            objD(50, 10);  
            Console.ReadLine();  
        }  
    }  
}   
To add reference of more functions to a delegate object, we use += operator.
objD += obj1.substract;  
objD += obj1.Add;   
To delete the reference of any function from Delegate object, we use -= operator.
objD -= obj1.substract;  
objD = -obj1.Add;   
 
Go To Top
 
MVC
MVC LifeCycle
Routing->MVCHandler (implements IHttpHandler interface & runs ProcessRequest() & Controller initialization->Action Execution->Result Execution->View Initialization & Rendering.
Routing: When a matching pattern is found in the Route Table, the Routing engine forwards the request to the corresponding IRouteHandler for that request. The default one calls the MvcHandler. An application has only one Route Table and this is setup in the Global.asax file of the application (In Application_Start event).
public static void RegisterRoutes(RouteCollection routes)
{
routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
routes.MapRoute( "Default", // Route name
"{controller}/{action}/{id}", // URL with parameters
new { controller = "Home", action = "Index", id = UrlParameter.Optional } // Parameter defaults
);
}
2. MvcHandler & Controller initialization: The MvcHandler initiates the real processing inside the MVC pipeline by using ProcessRequest method. This method uses the IControllerFactory instance (default is System.Web.Mvc.DefaultControllerFactory) to create corresponding controller. (i.e. instantiating the controller)
3. Action Execution: Once the controller has been instantiated, Controller's ActionInvoker determines which specific action to invoke on the controller.
After choosing appropriate action method, model binders(default is System.Web.Mvc.DefaultModelBinder) retrieves the data from incoming HTTP request and do the data type conversion, data validation such as required or date format etc. and also take care of input values mapping to that action method parameters.
Authentication Filter
Authorization filter
Action filters are executed before(OnActionExecuting) and after(OnActionExecuted) an action is executed.
4. Result Execution:
Result filters are executed before(OnResultExecuting) and after(OnResultExecuted) the ActionResult is executed.
The Action Result type can be ViewResult, PartialViewResult, RedirectToRouteResult, RedirectResult, ContentResult, JsonResult, FileResult and EmptyResult.
5. View Engine (Initialization): The first step in the execution of the View Result involves the selection of the appropriate View Engine to render the View Result. It is handled by the IViewEngine interface of the view engine. By default the MVC uses WebForm and Razor view engines. You can also register your own custom view engine to your Asp.Net MVC.

6. View Rendering: Action method may return a text string,a binary file or a Json formatted data. ViewResult renders and returns an HTML page to the browser by using the current view engine.

 
Go To Top
 
Creating custom filters.
To create your own custom filter, the MVC framework provides a base class which is known as ActionFilterAttribute. This class implements both IActionFilter and IResultFilter interfaces and both are derived from the Filter class.
Add one class ‘MyLogActionFilter’. This class will be derived from the ActionFilterAttribute.
public class MyLogActionFilter : ActionFilterAttribute{
     public override void OnActionExecuting(ActionExecutingContext filterContext){
        Log("OnActionExecuting", filterContext.RouteData);
     }
}
[MyLogActionFilter]
  public class HomeController : Controller{
     // GET: Home
ActionFilter:
use the OnActionExecuting method to open a Db Session and the OnActionExecuted method to save the Session data if there are no errors. This leaves the Controller method with the responsibility of checking/validating the incoming data only.
Go To Top
 
ViewData, ViewBag & TempData:

ViewData: Derived from the ViewDataDictionary class and is basically a Dictionary object. While retrieving data, the data needs to be Type Cast to its original type, as it will be stored as an object.
ViewData["Message"] = "Hello Ankit!";

ViewBag: ViewBag is a Wrapper built around ViewData. ViewBag is a dynamic property. While retrieving data, there is no need for Type Casting the data.
ViewBag.Message = "Hello Sultan!";

TempData: A Dictionary object. While retrieving, the data it needs to be Type Casted to its original type as the data is stored as objects. TempData can be used for passing a value from the Controller to the View and also from the Controller to another Controller. TempData is available for current and subsequent requests. It will not be destroyed on redirection.
ViewBag.username=”hvkn”->cannot be used to retrieve value from one action method to another action method of the same controller.
ViewData[“UserName”]=”gvhbh”->cannot be used to retrieve value from one action method to another action method of the same controller.
TempData[“UserName”]=”gvhbh”->can be used to retrieve value from one action method to another action method of the same controller/different controller.
Go To Top
 
Exception Handling in MVC:
5 Ways to do MVC Error Handling:
MVC HandleError Attribute (applicable to each controller/action)
override Controller.OnException method (applicable to each controller/action)
Inheriting from HandleErrorAttribute (which can be used across multiple controllers)
Global Error Page With Web.Config <customErrors>
Try Catch block
1. HandleError Attribute:
[HandleError(ExceptionType = typeof(SqlException), View = "SqlExceptionView")]
public string GetClientInfo(string username)
{
	return "true";
}
For HandleError attribute to work, it is necessary to enable customErrors property in web.config.
It is not necessary to decorate every controller or action using [HandleError] attribute (unless you need to handle a very specific type of exception). You can simply add an entry in Global FilterConfig.cs file (4th type of exception handling) for the handle error attribute, which will be by default applicable to all the controllers & actions once the custom error is turned on in web.config file.
public class FilterConfig
   {
       public static void RegisterGlobalFilters(GlobalFilterCollection filters)
       {
           filters.Add(new HandleErrorAttribute());
       }
   }
2. Overriding Controller.OnException method
OnException is similar to HandleErrorAttribute but provides more flexibility. It works with all HTTP status codes, and not just 500 level responses. It also gives you the ability to log the errors!
public class HomeController : Controller
{
       protected override void OnException(ExceptionContext filterContext)
       {
           Exception ex = filterContext.Exception;
			_Logger.Error(filterContext.Exception);
           filterContext.ExceptionHandled = true;
    		var model = new HandleErrorInfo(filterContext.Exception, "Controller","Action");   	
			filterContext.Result = new ViewResult()
			{
               ViewName = "Error",
               ViewData = new ViewDataDictionary(model)
		     };
       }
}
If you want a way to present your users custom MVC views or custom log exceptions, OnException is a good solution for you. It provides more flexibility than HandleError Attribute and does not require customErrors to be enabled in your Web.Config file.
3. Inheriting from HandleErrorAttribute:
One of the biggest drawbacks of all the previous method except was re-usability. Error handling logic cannot be reused across other controllers.
In order to reuse error handling logic across controllers we can inherit from “HandleErrorAttribute”class and decorate this class as attribute across controller.
public class Err : HandleErrorAttribute
{
public override void OnException(ExceptionContext filterContext)
       {
           Exception ex = filterContext.Exception;
           filterContext.ExceptionHandled = true;
			var model = new HandleErrorInfo(filterContext.Exception, "Controller", "Action");
           filterContext.Result = new ViewResult()
           {
               ViewName = "Error1",
               ViewData = new ViewDataDictionary(model)
           };
       }
   }
Now we can decorate our action/controller with [Err] to use this.
The problem with HandleErrorAttribute is it doesn’t provide a way to log the exception!
4. Must Have: Global Error Page With Web.Config <customErrors>
The last thing you ever want your users to see is a “yellow screen of death” type error. If you don’t know what that is, I’m referring the standard yellow The Official Microsoft ASP.NET Site error screen.
For any application, I would always recommend specifying a custom error page in your Web.Config. Worst case scenario, your users will see this page if an unhandled exception occurs.
<system.web>
   <customErrors mode="On" defaultRedirect="~/ErrorHandler/Index">
       <error statusCode="404" redirect="~/ErrorHandler/NotFound"/>
   </customErrors>
<system.web/>
You can add the below code in the ~/ErrorHander/Index.cshtml view to check the exception details:
@if (Model != null && HttpContext.Current.IsDebuggingEnabled)
   {
       <div>
           <p>
               <b>Exception:</b> @Model.Exception.Message<br />
               <b>Controller:</b> @Model.ControllerName<br />
               <b>Action:</b> @Model.ActionName
           </p>
           <div style="overflow:scroll">
               <pre>
                   @Model.Exception.StackTrace
               </pre>
           </div>
       </div>
   }
And you need to add HandleErrorAttribute globally in FilterConfig.cs:
public class FilterConfig
   {
       public static void RegisterGlobalFilters(GlobalFilterCollection filters)
       {
           filters.Add(new HandleErrorAttribute());
       }
   }
5. Try catch block
The best approach is to use both 3 and 4 i.e. Inheriting from HandleErrorAttribute and Global Error Page With Web.Config <customErrors>
Go To Top
 
Custom Form Authentication:
Set mode in web.config.
use FormsAuthentication.SetAuthCookie for login
use FormsAuthentication.SignOut for logout
<system.web>
<Authentication mode=”Forms”>
<forms loginurl=”Account/Login”></forms>
</Authentication>
</system.web>
2. Decorate your controller with [authorize] attribute or register authorize attribute globally in global.asax:
protected void Application_Start()
      {
          GlobalFilters.Filters.Add(new AuthorizeAttribute());
      }
And wherever you require to allow anonymous access, decorate those methods with [AllowAnonymous] attribute.
3. To put login and log out button:
@if (User.Identity.IsAuthenticated)
                  {
                      <li>@Html.ActionLink("Log Out", "LogOut", "UserProfile")</li>
                  }
else
                  {
                      <li>@Html.ActionLink("Log In", "LogIn", "UserProfile")</li>
                  }
Implementing role based authorization:
Create a class globally, give it any name like ‘WebRoleProvider’ and inherit it from ‘RoleProvider’
Implement all the methods of ‘RoleProvider’ class.
2. Goto web.config and add:
<rolemanager defaultProvider=”myRoleProvider” enabled=”true”>
<providers >
<clear/>
<add name=”myRoleProvider” type=”<namespacename>.WebRoleProvider”/>
</providers>
</rolemanager>
3. In the ‘WebRoleProvider’ class, fetch all the roles of a user by adding code to GetRoleForUser method:

4. Now the actions which you want to be accessible to only particular rows, should be decorated with the ‘Authorize’ attribute like:
[Authorize(Roles=”Admin”,”Customer”]
Go To Top

What are different types of return values in controller’s action?
Return View->returns a normal view
Return partial View->
Return Redirect->This is equivalent to Response.redirect() or Server.Transfer() functions. It takes the URL path to be redirect
Return RedirectToAction->Sometimes it is necessary to call another action after completion of one action.
Return JSON->This is very useful when we don't want an entire HTML page but only want a value. Generally in AJAX-based single-page applications we do not load an entire page again and again but load fresh data from the DB using AJAX.
Return File>We are allowed to return a binary file if needed from a controller.
Return content->This is useful when we want to return a small amount of strings from a controller/action.
Return JavaScript->When we wanted to return a JavaScript string
Go To Top
 
How to call a controller method using Ajax?
var value;
$.ajax({
   url: '/HomeController/YourMethodName',
   type: 'POST',   
   dataType: 'json',
   data: { id: 'value' },
   success: function (data) {
       alert("success");
   },
   error: function () {
       alert('error');
   }
});
Ex. to delete an item from the DB using jQuery.ajax with POST method:
Action in CategoryController:
[HttpPost]
public ActionResult Delete(int id) {
 try {
   db.CategoryRepository.Delete(id);
   db.Save();
   return Json(new {Result = "OK"});
 } catch (Exception ex) {
   return Json(new { Result = "ERROR", Message = ex.Message });
 }
}
View:
<a id="delete-category" class="btn btn-small" href="#">
 <i class="icon-remove"></i>
 @Resource.delete
</a>
$.ajax({
   type: 'POST', // <-- add this
   url: '@Url.Action("Delete","Category")',
   dataType: 'json',
   data: { id: '@Model.CategoryModel.Id' },
   success: function (data, textStatus, jqXHR) {
       console.log("success");
   },
   error: function () {
       alert('error');
   }
});
Go To Top

Add Custom Errors.
if (ModelState.IsValid) {            
   //check whether name is already exists in the database or not
   bool nameAlreadyExists = * check database *            
   if(nameAlreadyExists)
   {
       ModelState.AddModelError(string.Empty, "Student Name already exists.");
  
       return View(std);
   }
}
Go To Top

Real time examples of implementing custom filters.

Authentication Filter:
Lets’ say we have below example:
[Authorize(Roles = "Admin, SuperAdmin")]  
public class AdminSuperAdminController : Controller    {       }
Now we want to apply this ‘Authorize’ filter to many controllers or action methods in the project. In general, what would we do is to copy-paste the attribute everywhere. This raises a concern of duplication and maintenance. Tomorrow, if we need to change role names to something else or need to add another role into it then we will have to find and replace from entire project. There are chances or errors in this plus a lot of work too.
The solution of this problem is to create a custom authentication filter and use that in the controller or action methods. If we need any change, we just need to modify the custom authentication filter code at one place and that will affect all controller and action methods that is using this custom filter.

Reference: Custom authentication filter in ASP.NET MVC
2. Authorization Filter:
ValidateUserRoles
here is a sample usage of [Authorize] attribute:
[Authorize(Roles="Administrator")]
But what if you don't know the role name at development time? What if the roles allowed to invoke an action method are coming from a database? In such cases you cannot use the [Authorize] attribute as shown above. To tackle this problem you will create a ValidateUserRoles custom action filter that will give you a chance to verify a currently logged in user against roles that are pulled from the database.


3. Action Filters:
TrackUserIP
At times you need to capture the IP address of the client invoking an action method (say for security, tracking or analytical reasons). The TrackUserIP action filter will do just that. The TrackUserIP is a normal action filter and hence will implement IActionFilter interface.

In both the methods we just log the IP address of the client to the Visual Studio Debug window. In a more realistic situation you will store it in some database. So the sequence of execution will be OnActionExecuting() - Action Method - OnActionExecuted().

4. Result Filter:
DisplayAds
A common scenario in web pages is to render advertisements. One way to achieve this is to include advertisement rendering logic in the web page itself. However, this approach may not be suitable in all the cases. The DisplayAds action filter appends advertisements when a result is processed. This way the view need not know anything about the advertisement display logic. They are emitted in the final output by the DisplayAds action filter. Since DisplayAds action filter works on the output of views it needs to implement IResultFilter interface.


5. Exception Filters:
NotifyException
The NotifyException action filter sends a notification to an email address whenever there is any error in an action method or view. You can use this action filter to notify the administrator or technical team about the exception so that corrective action can be taken if necessary.

Reference: Creating Custom Action Filters in ASP.NET MVC
Go To Top
